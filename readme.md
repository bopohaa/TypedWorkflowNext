
# Entrypoint

Entrypoint - обработчик который может принимать результат работы другиех обработчиков и возвращать результат своей работы в виде экземпляра класса (class или record) или структуры.
Входящие параметры это результаты работы других обработчиков
Результат работы обработчика это всегда уникальный тип в пределах всей системы. Не допускается двух обработчиков с одним и тем же типом результата.
Результат работы может быть сформирован в виде кортежа из нескольких уникальных типов, которые затем могут независимо использоваться другими обработчиками.

## Категории entrypoint

* Контекстно-зависимые
  Это могут быть любые публичные не статические методы размеченные атрибутом `TwEntrypoint`.
  В начале каждой итерации запуска всей системы создается новый экземпляр класса содержащий не статические обработчики.
* Контекстно-независимые - singletone
  Это могут быть любые публичные не статические методы размеченные атрибутом `TwEntrypoint` в размеченном атрибутом `TwSingleton` классе (компоненте).

## Типы entrypoint

* Пользовательские - явно заданы в рабочей системе
* Служебные - имеют вспомогательную роль (не явно добавляются по мере необходимости)
  

## Свойства entrypoint

* Приоритетная группа.
  Объеденяет обрабочики в группы, которые будут выполняться в заданном порядке.
* Локальный порядок выполнения.
  Задает порядок выполнения обработчиков одного общего класса. Если порядок нарушен из за связей то выдает исключение. Наличие этого атрибута у singleton обработчика указывает на то что он не может выполняться в отрыве от остальных обработчиков в этом классе имеющих локальный порядок. По умолчанию все не singletone обработчики имеют 0 порядок выполнения (т.е. выполняются в последнюю очередь).

## Наследование компоненов entrypoint

При наследовании компонента содержащего один или несколько entrypoint выполняется замена обработчиков базового компонента на обработчики из производного по схожему с наследованием методов алгоритму.
В данном наследовании нет необходимости в базовом компоненте иметь виртуальные обработчики, достаточно добавить идентичный по сигнатуре обработчик с затенением базого через ключевое слово new.
Правила наследования компонентов:
* Если в производном компоненте переопределить обработчик как простой метод (без атрибута TwEntrypoint), то такой обработчик исключается из потока выполнения.
* Если пометить производный компонент атрибутом TwIgnore то все обработчики этого компонента будут исключены из потока выполнения.
* Компоненты помеченные как singleton (атрибут TwSingleton), передают это свойство всем наследуемым потомкам (т.е. все обработчики этих компонентов будут обрабатываться как singleton).
* Не может быть более одного производного компонента т.к. это приведет к дублированию обработчиков.

# Домены entrypoint

* Домен является изолированной рабочей системой формируемой из существующих обработчиков которые могут зависить только от заданного списка параметров или параметров моделей которые формируются входящими в домен обработчиками. Также домен имеет строго определенный список формируемых моделей, т.е. все обработчики внутри домена должны произвести заданные модели используя указанный список входящих параметров.
* Домены могут иметь иерархию, т.е. вложенность.
* Домены не могут пересекаться т.к. это нарушает правило заданных входящих параметров и исходящих моделей (пересечение подразумевает использование одним доменом внутренних моделей другого и формирование моделей не включенных в список формируемых моделей другого домена).
* Домены должны содержать все обработчики с заданным локальным порядком выполнения (см. свойства entrypoint)
* Каждый домен должен иметь уникальное для рабочей системы имя
* Рабочая система по сути является корневым доменом со своим pipeline

## Типы доменов

* Пользовательские - явно задаются в описании рабочей системы в виде обработчиков
  Каждый пользовательский домен определяется как entrypoint в классе системы. При определении такого обработчика как partial будет создана реализация этого метода, в противном случае этот обработчик будет использоваться как точка входа, а реализация будет назначена другому partial методу со схожей сигнатурой (совпадение входящих и исходящих параметорв).
* Служебные, определяются неявно в зависимости от использования перебираемых значений IEnumerable<> и IReadOnlyCollection<> обработчиками. Не имеют ограничения по наличию всех обработчиков с заданным локальным приоритетом, но при этом имеют ограничение на порядок выполнения.


# Типы моделей

Каждый обработчик может вернуть экземпляр уникального класса или структуры.
Каждый обработчик может получить на вход произвольное количество ранее созданных другими обработчиками экземпляров классов и структур.
Каждый экземпляр возвращаемого значения должен быть не изменяемым (immutable), хорошей практикой будет использование структур и записей (record) или классов с неизменным состоянием (все поля и свойства должны быть только для чтения)

Возвращаемые типы:

* Экзмепляр класса, структуры или записи.
* ValueTuple<> от двух и более уникальных типов, данный тип декомпозируется на отдельные типы, которые можно независимо передавать в другие обработчики
* ValueTask<> выполняет асинхронное/синхронное ожидание результата, который может декомпозироваться.
* IEnumerable<> формирует служебный домен который выполняет все зависимые обработчики столько раз сколько доступно значений в IEnumerable. Все исходящие значения этого домена имеют тип IReadOnlyCollection<>. 
* IReadOnlyCollection<> может использоваться как входящий параметр или как служебный домен с перебором всех значений (аналогично IEnumerable<>)
* Nullable<>, позволяет запускать условное выполнение обработчиков. Все обработчики зависимые от декомпозированноых типов будут перед вполнением делать проверку наличия значения и в случае отсутствия пропускать свое выполнение, а результат работы таких обработчиков автоматом приводится к Nullable<>. Может использоваться как входящий параметр

## Супер модели
Классы с открытми на чтение и запись полями, которые являются результатом работы обработчиков.
Экземпляры таких моделей могут быть созданы автоматически и переданы в качестве параметра любого обработчика.
Супер модели могут являться композицией из других супер моделей.
Супер модели могу иметь наследование от других супер моделей, при этом обработчики родительского типа супер модели будут получать экземпляр потомка, но с инициализацией только тех полей которые определены в родительском типе. Поэтому потомок у родителя может быть только один (иначе было бы не возможно определить какой именно экземпляр модели передавать в обработчик родительского типа супер модели).


# Алгоритм формирования графа выполнения

1. Поиск всех обработчиков, формирование графа вложенности - сборка, класс, обработчик
2. Исключение из системы родительских классов обработчиков
3. Поиск рабочих систем и наполнение классами обработчиков по индивидуальным для системы условиям отбора
4. Перевод иерархического графа вложенности обработчиков в плоский с добавлением служебных обработчиков (декомпозиция, асинхронное ожидание, перебор множества)
5. Поиск супермоделей, построение иерархии супермоделей и декомпозиция зависимостей обработчика от супермоделей
6. Поиск служебных доменов - домены перебора множеств
7. Поиск пользовательских доменов - домен без зависимостей или с зависимостями отсутствующими в системе считается входной точкой системы (в системе может быть только одна такая точка входа)
8. Формирование иерархии вложенности доменов
9. Рекурсивная замена обработчиков вошедших в домены низшего уровня на служебный обработчик домена
10. Выстраивание графа выполнения для каждого домена
11. Формирование реализации частичных методов каждого домена из графа выполнения обработчиков этих доменов

